#!/usr/bin/env php
<?php

function main($argv, $argc){
    print("RepoRangler: CLI\n");

    $argList = array_slice($argv,1);

    $unknownCommand = true;

    foreach($argList as $arg){
        list($arg, $value) = explode("=",$arg) + [null, null];
        $method = Command::commandToMethod($arg);

        if(!empty($method)){
            $unknownCommand = false;
            call_user_func_array($method, [$arg, $value, $argList]);
        }
    }

    if($unknownCommand){
        print("All Supported Commands, use 'reporangler <command> --help' to obtain details about how to use each command:\n");
        $methodList = get_class_methods(RepoRangler::class);
        foreach($methodList as $method){
            $cmd = Command::methodToCommand($method);
            print("  - $cmd\n");
        }
    }
}

function array_pluck($array, $keys)
{
	return array_intersect_key($array, array_flip($keys));
}

try{
    Config::read();

    main($argv,$argc);
}catch(RepoRanglerCurlException $e){
    print("Curl has failed: ".$e->getMessage()."\n");
}catch(RepoRanglerValidationException $e){
    print($e->getMessage()."\n");
}catch(RepoRanglerException $e){
    if(strpos($e->data['message'], 'duplicate key') !== false){
        print("The information you provided already exists or was not unique enough\n");
    }else{
        print($e->getMessage()."\n");
        var_dump($e->data);
    }
}catch(Exception $e){
    print($e->getMessage()."\n");
}finally{
    Config::write();
}

class RepoRangler{
    static public function healthCheck($arg, $value, $argList)
    {
        $list = Config::getEndpoint();

        foreach($list as $service => $endpoint){
            try{
				print("Checking '$service': ");
				$response = Request::get("$endpoint/healthz");
				if(!empty($response) && array_key_exists('statusCode', $response)){
					print(($response['statusCode'] === 200 ? "OK" : "FAIL") . "\n");
				}else{
					print("FAIL - Unknown reason\n");
				}
            }catch(Exception $e){
				print("FAIL - Exception Thrown, message = '".$e->getMessage()."'\n");
            }
        }
    }

    static public function login($arg, $value, $argList)
    {
        $username = readline('Enter Username: ');
        $password = readline('Enter Password: ');

		$endpoint = Config::getEndpoint('auth');
        $headers = Request::getLoginHeaders($username, $password);
        $response = Request::get("$endpoint/login/api", $headers);

        if(array_key_exists('token', $response)){
            Config::setToken($response['token']);
            Config::setUserId($response['id']);
            print("Login was successful, token: {$response['token']}\n");
        }else{
            print("Login has failed\n");
        }
    }

    static public function listUser($arg, $value, $argList)
    {
		$endpoint = Config::getEndpoint('auth');

        $response = Request::get("$endpoint/user");

        print("User List: \n");
        if(!empty($response['data'])){
			foreach($response['data'] as $user){
				print("  - {$user['username']}\n");
			}
        }else{
            print("** EMPTY **\n");
        }
    }

    static public function createUser($arg, $value, $argList)
    {
        $username = readline('Enter Username: ');
        $email = readline('Enter Email: ');
        $password = readline('Enter Password: ');

		$endpoint = Config::getEndpoint('auth');

        $response = Request::post("$endpoint/user", [
            'username' => $username,
            'email' => $email,
            'password' => $password,
        ]);

        print("The User was created successfully\n");
    }

    static public function deleteUser($arg, $username, $argList)
    {
        if(empty($username) || !is_string($username)){
            die("The username must be a non-empty string");
        }

		$endpoint = Config::getEndpoint('auth');

        $response = Request::get("$endpoint/user/username/$username");

        Request::delete("$endpoint/user/{$response['id']}");

        print("The user was deleted successfully\n");
    }

    static public function userInfo($arg, $username, $argList)
    {
		$endpoint = Config::getEndpoint('auth');

		if(!empty($username) && is_string($username)){
		    try{
				$response = Request::get("$endpoint/user/$username");
            }catch(RepoRanglerException $e){
				die("The user with the username '$username' was not found\n");
            }
        }else{
		    $userId = Config::getUserId();

		    $response = Request::get("$endpoint/user/$userId");
        }

		$is = [
            'admin' => $response['is_admin_user'] ? 'yes' : 'no',
            'rest' => $response['is_rest_user'] ? 'yes' : 'no'
        ];

		print("The user '{$response['username']}' was found:\n");
		print("  Username: {$response['username']}\n");
		print("  Email: {$response['email']}\n");
		print("  Type: \n");
		print("    Admin: {$is['admin']}\n");
		print("    Rest Access: {$is['rest']}\n");
		print("  Package Groups: \n");
		if(!empty($response['package_groups'])){
			foreach($response['package_groups'] as $name => $access){
				$access = $access === "PACKAGE_GROUP_ADMIN" ? 'admin' : 'member';
				print("    $name: $access\n");
			}    
        }else{
		    print("    ** EMPTY **\n");
        }
		
		print("  Access Tokens: (TODO: hide if not your own tokens)\n");
		if(!empty($response['access_tokens'])){
            foreach($response['access_tokens'] as $token){
                print("    {$token['type']}: {$token['token']}\n");
            }
		}else{
			print("    ** EMPTY **\n");
		}

		print("  Raw Capability List: (TODO: We should remove this eventually)\n");
		if(!empty($response['capability'])){
            foreach($response['capability'] as $cap){
                $constraint = $cap['constraint'] !== null ? json_encode($cap['constraint']) : "No Constraints given";

                print("    {$cap['name']}: $constraint\n");
            }
		}else{
			print("    ** EMPTY **\n");
		}
		print("  Created At: {$response['created_at']}\n");
		print("  Updated At: {$response['updated_at']}\n");
    }

    static public function listPackageGroup($arg, $value, $argList)
    {
		$endpoint = Config::getEndpoint('metadata');

        $response = Request::get("$endpoint/package-group");

        print("Package Groups: \n");
		if(!empty($response['data'])) {
			foreach ($response['data'] as $packageGroup) {
				print("  - {$packageGroup['name']}\n");
			}
		}else{
		    print("  **EMPTY**\n");
        }
    }

    static public function createPackageGroup($arg, $packageGroup, $argList)
    {
        if(empty($packageGroup) || !is_string($packageGroup)){
            die("The package group name must be a non-empty string");
        }

		$endpoint = Config::getEndpoint('metadata');

        $response = Request::post("$endpoint/package-group", ['name' => $packageGroup]);

        print("The Package group '$packageGroup' was created successfully\n");
    }

    static public function deletePackageGroup($arg, $packageGroup, $argList)
    {
        if(empty($packageGroup) || !is_string($packageGroup)){
            die("The package group name must be a non-empty string");
        }

		$endpoint = Config::getEndpoint('metadata');

        $response = Request::get("$endpoint/package-group/name/$packageGroup");

        Request::delete("$endpoint/package-group/{$response['id']}");

        print("The Package group '$packageGroup' was deleted successfully\n");
    }

    static public function addAccessToken($arg, $value, $argList)
    {
        $fields = array_fill_keys(['user_id', 'type', 'token'], null);

		foreach($argList as $arg) {
			list($arg, $value) = Command::extractArg($arg);

			switch ($arg) {
				case 'type':
					$fields['type'] = $value;
					break;

                case 'token':
                    $fields['token'] = $value;
                    break;

                case 'user':
					// do nothing yet, but should lookup a user by username and acquire the user_id
                    break;
			}
		}

		if($fields['user_id'] === null){
		    $fields['user_id'] = Config::getUserId();
        }

		if(in_array(null, $fields)){
			throw new CommandFieldEmptyException();
		}

		$endpoint = Config::getEndpoint('auth');

		$response = Request::post("$endpoint/access-token/{$fields['user_id']}", [
            'user_id' => $fields['user_id'],
            'type' => $fields['type'],
            'token' => $fields['token'],
		]);

		if(empty($response)){
		    die("An unexpected empty response was returned\n");
        }

		if(!array_key_exists('type', $response) || $response['type'] !== $fields['type']){
		    die("The type of this response was not found, or not the requested type\n");
        }

		if(!array_key_exists('token', $response) || $response['token'] !== $fields['token']){
		    die("The token of this response was not found, or not the requested text\n");
        }

		print("Token '{$response['type']}' with key '{$response['token']}' was successfully created\n");
    }

	static public function listAccessToken($arg, $value, $argList)
	{
		$fields = array_fill_keys(['user_id'], null);

		foreach ($argList as $arg) {
			list($arg, $value) = Command::extractArg($arg);

			switch ($arg) {
				case 'user':
					// do nothing yet, but should lookup a user by username and acquire the user_id
					break;
			}
		}

		if ($fields['user_id'] === null) {
			$fields['user_id'] = Config::getUserId();
		}

		if (in_array(null, $fields)) {
			throw new CommandFieldEmptyException();
		}

		$endpoint = Config::getEndpoint('auth');

		$response = Request::get("$endpoint/access-token/{$fields['user_id']}");

		if(empty($response['data'])){
			print("There were no tokens by this user to delete\n");
			return;
		}

		print("The following tokens were found:\n");
		if(!empty($response['data'])){
			foreach($response['data'] as $index => $token){
				print("  ".($index+1).": {$token['type']}\n");
			}
        }else{
		    print("  **EMPTY**\n");
        }
	}

    static public function removeAccessToken($arg, $value, $argList)
    {
        $fields = array_fill_keys(['user_id', 'type'], null);

		foreach($argList as $arg) {
			list($arg, $value) = Command::extractArg($arg);

			switch ($arg) {
				case 'type':
					$fields['type'] = $value;
					break;

				case 'user':
					// do nothing yet, but should lookup a user by username and acquire the user_id
					break;
			}
		}

		if($fields['user_id'] === null){
			$fields['user_id'] = Config::getUserId();
		}

        if(in_array(null, $fields)){
			throw new CommandFieldEmptyException();
		}

		$endpoint = Config::getEndpoint('auth');

		$response = Request::get("$endpoint/access-token/{$fields['user_id']}");

		if(empty($response['data'])){
		    print("There were no tokens by this user to delete\n");
		    return;
        }

		print("Please choose a token to delete:\n");
		if(!empty($response['data'])){
			foreach($response['data'] as $index => $token){
				print("  ".($index+1).": {$token['type']}\n");
			}
			$id = readline("Enter id: ");
			$id = intval($id);
			if($id < 1) die("The Id given was not a positive integer");

			$response = Request::delete("$endpoint/access-token/{$fields['user_id']}/{$response[$id-1]['id']}");

			if(array_key_exists('deleted', $response) && count($response['deleted']) === 1){
				$deleted = current($response['deleted']);
				print("Token '{$deleted['type']}' with key '{$deleted['token']}' was successfully deleted\n");
			}else{
				print("Something went wrong, but the expected response was not found\n");
			}
        }else{
		    print("  **EMPTY**\n");
        }
	}

    static public function publish($arg, $value, $argList)
    {
        $scannerTypes = ['github', 'gitlab', 'vcs'];

        if(Command::hasHelp($argList)){
            print("Example: publish --(repository|repo)=php --package-group=public --url=https://github.com/reporangler/lib-reporangler\n");
            print("  --(repository|repo)=php: The name of the repository that this package will be published into\n");
            print("  --package-group=public: The name of the package group that this package will be associated with\n");
            print("  --url=https://...: The url of the project from where to obtain packages from\n");
            print("  --scanner=(".implode("|",$scannerTypes)."): The type of repository scanner to use, must be one of the listed types\n\n");
            print("NOTE: It's true that not all packages come from a VCS, but at the moment, it's the only supported type\n");
            print("NOTE: The scanner will default to using the type coming from the url if you do not specify any, if the url is not github or gitlab, vcs will be used\n");
            die();
        }

        $fields = array_fill_keys(['repository','scanner','package-group','url'], null);

        foreach($argList as $arg){
			list($arg, $value) = Command::extractArg($arg);

			if($arg === 'repo') $arg = 'repository';

			$fields[$arg] = $value;
        }

        if($fields['scanner'] === null){
            $fields['scanner'] = 'vcs';

            foreach($scannerTypes as $type){
                if(strpos($fields['url'], $type) !== false){
                    $fields['scanner'] = $type;
                }
            }
        }

        if(in_array(null, $fields)){
            throw new CommandFieldEmptyException();
        }

		$endpoint = Config::getEndpoint($fields['repository']);

		$response = Request::post($endpoint, [
            'url' => $fields['url'],
            'type' => $fields['scanner'],
            'package_group' => $fields['package-group'],
        ]);

		foreach($response as $package => $version){
			print("Published Package: '$package' from '{$fields['url']}'\n");
			foreach(array_keys($version) as $version){
			    print("  - $version\n");
            }
        }
	}

	public function listRepository($arg, $value, $argList)
    {
        $endpoint = Config::getEndpoint('metadata');
        $response = Request::get("$endpoint/repository");

        print("List of Supported Repositories: \n");
        foreach($response as $repo){
            print("  - ${repo['name']}\n");
        }
    }

    public function createRepository($arg, $repo, $argList)
    {
        if(empty($repo) || !is_string($repo)){
            die("The repository name must be a non-empty string");
        }

        $endpoint = Config::getEndpoint('metadata');

        $response = Request::post("$endpoint/repository",['name' => $repo]);

        print("Repository '{$response['name']}' was successfully created\n");
    }

    public function updateRepository($arg, $repo, $argList)
    {
        if(empty($repo) || !is_string($repo)){
            die("The repository name must be a non-empty string");
        }

        $endpoint = Config::getEndpoint('metadata');

        $repo = Request::get("$endpoint/repository/$repo");

        $name = Command::getArg($argList, 'name');
        if(empty($name)) $name = readline("Enter a new name for this repository: ");

        $response = Request::put("$endpoint/repository/${repo['id']}",['name' => $name]);

        print("Repository '{$repo['name']}' was renamed to '{$response['name']}' successfully\n");
    }

    public function deleteRepository($arg, $repo, $argList)
    {
        if(empty($repo) || !is_string($repo)){
            die("The repository name must be a non-empty string");
        }

        $endpoint = Config::getEndpoint('metadata');

        $repo = Request::get("$endpoint/repository/$repo");

        $response = Request::delete("$endpoint/repository/${repo['id']}");

        print("Repository '{$repo['name']}' was deleted successfully\n");
    }

    public function joinPackageGroup($arg, $repo, $argList)
    {
		$fields = array_fill_keys(['user', 'package-group', 'access', 'admin'], null);
		$required = ['user', 'package-group'];

		$fields = Command::pluckArgs($argList, $fields, $required);

		$data = [];

		$auth = Config::getEndpoint('auth');
		$user = Request::get("$auth/user/{$fields['user']}");
		$data['user_id'] = $user['id'];

		$metadata = Config::getEndpoint('metadata');
		$packageGroup = Request::get("$metadata/package-group/${fields['package-group']}");
		$data['package_group_id'] = $packageGroup['id'];

		if($fields['access']) $data['access'] = $fields['access'];
		if($fields['admin']) $data['admin'] = $fields['admin'];

		$response = Request::post("$auth/permission/user/package-group/join", $data);

        var_dump($response);
    }

	public function leavePackageGroup($arg, $repo, $argList)
	{
		die(__METHOD__ . " NOT IMPLEMENTED YET");
	}

	public function requestJoinPackageGroup($arg, $repo, $argList)
	{
		die(__METHOD__ . " NOT IMPLEMENTED YET");
	}

	public function joinRepository($arg, $repo, $argList)
	{
		die(__METHOD__ . " NOT IMPLEMENTED YET");
	}

	public function leaveRepository($arg, $repo, $argList)
	{
		die(__METHOD__ . " NOT IMPLEMENTED YET");
	}

	public function requestRepository($arg, $repo, $argList)
	{
		die(__METHOD__ . " NOT IMPLEMENTED YET");
	}

	public function protectPackageGroup($arg, $repo, $argList)
	{
		die(__METHOD__ . " NOT IMPLEMENTED YET");
	}

	public function unprotectPackageGroup($arg, $repo, $argList)
	{
		die(__METHOD__ . " NOT IMPLEMENTED YET");
	}

	public function protectRepository($arg, $repo, $argList)
	{
		die(__METHOD__ . " NOT IMPLEMENTED YET");
	}

	public function unprotectRepository($arg, $repo, $argList)
	{
		die(__METHOD__ . " NOT IMPLEMENTED YET");
	}
}

class Config{
    const file = __DIR__ . '/.reporangler.config';
    const user_agent = 'reporangler-cli';

    const defaults = [
        'endpoints' => [
            'auth' => 'http://auth.reporangler.develop',
            'metadata' => 'http://metadata.reporangler.develop',
            'php' => 'http://php.reporangler.develop',
            'npm' => 'http://npm.reporangler.develop',
            'storage' => 'http://storage.reporangler.develop',
        ]
    ];

    static public $state = [];

    static public function read(){
        self::$state = file_exists(self::file)
            ? json_decode(file_get_contents(self::file), true)
            : self::defaults;
    }

    static public function write(){
        return file_put_contents(self::file, json_encode(self::$state, JSON_PRETTY_PRINT));
    }

    static public function getEndpoint($name = null)
    {
        if(empty(self::$state)) {
            die("State: Was empty\n");
        }

        if(!array_key_exists('endpoints', self::$state)) {
            die("State: Endpoints are not configured\n");
        }

        if($name && !array_key_exists($name, self::$state['endpoints'])) {
            die("State: Endpoint '$name' does not exist\n");
        }

        return $name ? self::$state['endpoints'][$name] : self::$state['endpoints'];
    }

    static public function setToken($token)
    {
        self::$state['login_token'] = $token;
    }

    static public function getToken()
    {
        return array_key_exists('login_token', self::$state)
            ? self::$state['login_token']
            : null;
    }

    static public function setUserId($userId)
    {
        self::$state['user_id'] = $userId;
    }

    static public function getUserId()
    {
        return self::$state['user_id'];
    }
}

class Request{
    static public $statusCode = 500;

    private function exec($method, $url, $data, $headers)
    {
        $curl = curl_init();

        if(empty($headers)){
            $headers = Request::getTokenHeaders();
        }

        $headers[] = 'Content-Type: application/json';

        // Coerce the method to a set of allowed types
        $method = in_array($method, ['GET', 'POST', 'PUT', 'DELETE']) ? $method : 'GET';

        curl_setopt($curl, CURLOPT_URL, $url);
        curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method);
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($curl, CURLOPT_USERAGENT, Config::user_agent);
        curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);

        if(!empty($data)){
            curl_setopt($curl, CURLOPT_POST, true);
            curl_setopt($curl, CURLOPT_POSTFIELDS, json_encode($data));
        }

        Request::$statusCode = 500;

        $result = curl_exec($curl);

        $statusCode = Request::$statusCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);

        if(!strlen($result)) throw new Exception('The api request returned an empty response');

        $json = json_decode($result, true);

        switch(Request::$statusCode){
            case 200:
                return $json;
                break;

            case 404:
                throw new RepoRanglerException("The resource was not found ($statusCode)", $json);
                break;

            case 422:
                switch($json['exception']){
                    case 'Illuminate\Validation\ValidationException':
                        throw new RepoRanglerValidationException($json);
                        break;

                    case 'Symfony\Component\HttpKernel\Exception\UnprocessableEntityHttpException':
                        throw new RepoRanglerAlreadyExistsException($json['message']);
                        break;
                }
        }

        throw new RepoRanglerException("There was a generic unknown error ($statusCode)", $json);
    }

    public function get($url, $headers=[])
    {
        return self::exec('GET', $url, null, $headers);
    }

    public function post($url, $data, $headers=[])
    {
        return self::exec('POST', $url, $data, $headers);
    }

    public function put($url, $data, $headers=[])
    {
        return self::exec('PUT', $url, $data, $headers);
    }

    public function delete($url, $headers=[])
    {
        return self::exec('DELETE', $url, null, $headers);
    }

    public function getLoginHeaders($username, $password)
    {
        return [
            "reporangler-login-type: database",
            "reporangler-login-username: $username",
            "reporangler-login-password: $password",
        ];
    }

    public function getTokenHeaders()
    {
        $token = Config::getToken();

        if(empty($token)){
            die("Token was empty, you must login first\n");
        }

        return ["Authorization: Bearer {$token}"];
    }
}

class Command
{
    static public function methodToCommand($method)
    {
		$parts = preg_split('/(?=[A-Z])/', $method, -1, PREG_SPLIT_NO_EMPTY);
		return strtolower(implode('-', $parts));
    }

	static public function commandToMethod($arg)
	{
		$command = trim($arg,'-');
		$command = str_replace('-', ' ', $command);
		$command = ucwords($command);
		$command = str_replace(' ', '', $command);
		$command = lcfirst($command);

		if(method_exists("RepoRangler", $command)) {
			return "RepoRangler::$command";
		}

		$altArg = rtrim($arg, 's');
		if($altArg === $arg) return null;

		print("Command '$arg' did not exist, trying '$altArg'\n");
		return self::commandToMethod($altArg);
	}

	static public function extractArg($arg)
    {
		list($arg, $value) = explode("=",$arg) + [null, null];

		return [trim($arg,'-'), $value];
    }

    static public function pluckArgs($argList, $fields, $required)
    {
		foreach($argList as $arg){
			list($arg, $value) = Command::extractArg($arg);

			if(array_key_exists($arg, $fields)){
			    if($value === null) $value = true;

				$fields[$arg] = $value;
			}
		}

		if(in_array(null, array_pluck($fields, $required))){
			throw new CommandFieldEmptyException();
		}

		return $fields;
    }

    static public function getArg($argList, $name)
    {
        if(!is_array($argList)) return null;

        foreach($argList as $arg){
            list($arg, $value) = self::extractArg($arg);

            if($arg === $name) return $value;
        }

        return null;
    }

    static public function hasHelp($argList)
    {
        return self::getArg($argList, 'help') !== null;
    }
}

class RepoRanglerException extends \Exception{
    public $data;

    public function __construct($message = null, $data = [])
    {
        $this->data = $data;

        parent::__construct($message);
    }
}
class RepoRanglerCurlException extends RepoRanglerException{}
class RepoRanglerAlreadyExistsException extends RepoRanglerException{}

class RepoRanglerValidationException extends RepoRanglerException{
    public function __construct($data = [])
    {
        $keys = implode(', ', array_keys($data['validation']));
        $message = "Validation has failed because the following fields were not valid: $keys";

        parent::__construct($message, $data['validation']);
    }
}

class CommandFieldEmptyException extends \Exception{
    public function __construct($message="There are missing command parameters that were required", $code=0){
        parent::__construct($message, $code);
    }
}
