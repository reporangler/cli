#!/usr/bin/env php
<?php

function main($argv, $argc){
    print("RepoRangler: CLI\n");

    $argList = array_slice($argv,1);

    $unknownCommand = true;

    foreach($argList as $arg){
        list($arg, $value) = explode("=",$arg) + [null, null];
        $method = Command::computeMethodName($arg);

        if(!empty($method)){
            $unknownCommand = false;
            call_user_func_array($method, [$arg, $value, $argList]);
        }
    }

    if($unknownCommand){
        print("No command was found to process\n");
    }
}

try{
    Config::read();

    main($argv,$argc);
}catch(RepoRanglerCurlException $e){
    print("Curl has failed: ".$e->getMessage()."\n");
}catch(RepoRanglerValidationException $e){
    print($e->getMessage()."\n");
}catch(RepoRanglerException $e){
    print($e->getMessage()."\n");
    var_dump($e->data);
}catch(Exception $e){
    print($e->getMessage()."\n");
}finally{
    Config::write();
}

class RepoRangler{
    static public function login($arg, $value, $argList)
    {
        $username = readline('Enter Username: ');
        $password = readline('Enter Password: ');

		$endpoint = Config::getEndpoint('auth');
        $headers = Request::getLoginHeaders($username, $password);
        $response = Request::get("$endpoint/login/api", $headers);

        if(array_key_exists('token', $response)){
            Config::setToken($response['token']);
            Config::setUserId($response['id']);
            print("Login was successful, token: {$response['token']}\n");
        }else{
            print("Login has failed\n");
        }
    }

    static public function listUser($arg, $value, $argList)
    {
		$endpoint = Config::getEndpoint('auth');
        $headers = Request::getTokenHeaders();

        $response = Request::get("$endpoint/user", $headers);

        print("User List: \n");
        foreach($response['data'] as $user){
            print("  - {$user['username']}\n");
        }
    }

    static public function createUser($arg, $value, $argList)
    {
        $username = readline('Enter Username: ');
        $email = readline('Enter Email: ');
        $password = readline('Enter Password: ');

		$endpoint = Config::getEndpoint('auth');
        $headers = Request::getTokenHeaders();

        $response = Request::post("$endpoint/user", [
            'username' => $username,
            'email' => $email,
            'password' => $password,
        ], $headers);

        print("The User was created successfully\n");
    }

    static public function deleteUser($arg, $username, $argList)
    {
        if(empty($username) || !is_string($username)){
            die("The username must be a non-empty string");
        }

		$endpoint = Config::getEndpoint('auth');
        $headers = Request::getTokenHeaders();

        $response = Request::get("$endpoint/user/username/$username", $headers);

        Request::delete("$endpoint/user/{$response['id']}", $headers);

        print("The user was deleted successfully\n");
    }

    static public function userInfo($arg, $username, $argList)
    {
		$endpoint = Config::getEndpoint('auth');
		$headers = Request::getTokenHeaders();

		if(!empty($username) && is_string($username)){
		    try{
				$response = Request::get("$endpoint/user/username/$username", $headers);
            }catch(RepoRanglerException $e){
				die("The user with the username '$username' was not found\n");
            }
        }else{
		    $userId = Config::getUserId();

		    $response = Request::get("$endpoint/user/id/$userId", $headers);
        }

		$is = [
            'admin' => $response['is_admin_user'] ? 'yes' : 'no',
            'rest' => $response['is_rest_user'] ? 'yes' : 'no'
        ];

		print("The user '{$response['username']}' was found:\n");
		print("  Username: {$response['username']}\n");
		print("  Email: {$response['email']}\n");
		print("  Type: ADMIN[{$is['admin']}], REST[{$is['rest']}]\n");
		print("  Created At: {$response['created_at']}\n");
		print("  Updated At: {$response['updated_at']}\n");
		print("  Package Groups: \n");
		foreach($response['package_groups'] as $name => $access){
		    $access = $access === "PACKAGE_GROUP_ADMIN" ? 'admin' : 'member';
		    print("    $name: $access\n");
        }
		print("  Access Tokens: (TODO: hide if not your own tokens)\n");
		foreach($response['access_tokens'] as $token){
            print("    {$token['type']}: {$token['token']}\n");
        }
		print("  Raw Capability List: (TODO: We should remove this eventually)\n");
		foreach($response['capability'] as $cap){
			$constraint = $cap['constraint'] !== null ? json_encode($cap['constraint']) : "No Constraints given";

		    print("    {$cap['name']}: $constraint\n");
        }
    }

    static public function listPackageGroup($arg, $value, $argList)
    {
		$endpoint = Config::getEndpoint('auth');
        $headers = Request::getTokenHeaders();

        $response = Request::get("$endpoint/package-group", $headers);

        print("Package Groups: \n");
        foreach($response['data'] as $packageGroup){
            print("  - {$packageGroup['name']}\n");
        }
    }

    static public function createPackageGroup($arg, $packageGroup, $argList)
    {
        if(empty($packageGroup) || !is_string($packageGroup)){
            die("The package group name must be a non-empty string");
        }

		$endpoint = Config::getEndpoint('auth');
        $headers = Request::getTokenHeaders();

        $response = Request::post("$endpoint/package-group", [
            'name' => $packageGroup
        ], $headers);

        print("The Package group was created successfully\n");
    }

    static public function deletePackageGroup($arg, $packageGroup, $argList)
    {
        if(empty($packageGroup) || !is_string($packageGroup)){
            die("The package group name must be a non-empty string");
        }

		$endpoint = Config::getEndpoint('auth');
        $headers = Request::getTokenHeaders();

        $response = Request::get("$endpoint/package-group/name/$packageGroup", $headers);

        Request::delete("$endpoint/package-group/{$response['id']}", $headers);

        print("The Package group was deleted successfully\n");
    }

    static public function addAccessToken($arg, $value, $argList)
    {
        $fields = array_fill_keys(['user_id', 'type', 'token'], null);

		foreach($argList as $arg) {
			list($arg, $value) = Command::extractArg($arg);

			switch ($arg) {
				case 'type':
					$fields['type'] = $value;
					break;

                case 'token':
                    $fields['token'] = $value;
                    break;

                case 'user':
					// do nothing yet, but should lookup a user by username and acquire the user_id
                    break;
			}
		}

		if($fields['user_id'] === null){
		    $fields['user_id'] = Config::getUserId();
        }

		if(in_array(null, $fields)){
			throw new CommandFieldEmptyException();
		}

		$endpoint = Config::getEndpoint('auth');
		$headers = Request::getTokenHeaders();

		$response = Request::post("$endpoint/access-token/{$fields['user_id']}", [
            'user_id' => $fields['user_id'],
            'type' => $fields['type'],
            'token' => $fields['token'],
		], $headers);

		if(empty($response)){
		    die("An unexpected empty response was returned\n");
        }

		if(!array_key_exists('type', $response) || $response['type'] !== $fields['type']){
		    die("The type of this response was not found, or not the requested type\n");
        }

		if(!array_key_exists('token', $response) || $response['token'] !== $fields['token']){
		    die("The token of this response was not found, or not the requested text\n");
        }

		print("Token '{$response['type']}' with key '{$response['token']}' was successfully created\n");
    }

	static public function listAccessToken($arg, $value, $argList)
	{
		$fields = array_fill_keys(['user_id'], null);

		foreach ($argList as $arg) {
			list($arg, $value) = Command::extractArg($arg);

			switch ($arg) {
				case 'user':
					// do nothing yet, but should lookup a user by username and acquire the user_id
					break;
			}
		}

		if ($fields['user_id'] === null) {
			$fields['user_id'] = Config::getUserId();
		}

		if (in_array(null, $fields)) {
			throw new CommandFieldEmptyException();
		}

		$endpoint = Config::getEndpoint('auth');
		$headers = Request::getTokenHeaders();

		$response = Request::get("$endpoint/access-token/{$fields['user_id']}", $headers);

		if(empty($response)){
			print("There were no tokens by this user to delete\n");
			return;
		}

		print("The following tokens were found:\n");
		foreach($response as $index => $token){
			print("  ".($index+1).": {$token['type']}\n");
		}
	}

    static public function removeAccessToken($arg, $value, $argList)
    {
        $fields = array_fill_keys(['user_id', 'type'], null);

		foreach($argList as $arg) {
			list($arg, $value) = Command::extractArg($arg);

			switch ($arg) {
				case 'type':
					$fields['type'] = $value;
					break;

				case 'user':
					// do nothing yet, but should lookup a user by username and acquire the user_id
					break;
			}
		}

		if($fields['user_id'] === null){
			$fields['user_id'] = Config::getUserId();
		}

        if(in_array(null, $fields)){
			throw new CommandFieldEmptyException();
		}

		$endpoint = Config::getEndpoint('auth');
		$headers = Request::getTokenHeaders();

		$response = Request::get("$endpoint/access-token/{$fields['user_id']}", $headers);

		if(empty($response)){
		    print("There were no tokens by this user to delete\n");
		    return;
        }

		print("Please choose a token to delete:\n");
		foreach($response as $index => $token){
		    print("  ".($index+1).": {$token['type']}\n");
        }
		$id = readline("Enter id: ");
		$id = intval($id);
		if($id < 1) die("The Id given was not a positive integer");

		$response = Request::delete("$endpoint/access-token/{$fields['user_id']}/{$response[$id-1]['id']}", $headers);

		if(array_key_exists('deleted', $response) && count($response['deleted']) === 1){
		    $deleted = current($response['deleted']);
		    print("Token '{$deleted['type']}' with key '{$deleted['token']}' was successfully deleted\n");
        }else{
		    print("Something went wrong, but the expected response was not found\n");
        }
	}

    static public function publish($arg, $value, $argList)
    {
        if(Command::hasHelp($argList)){
            print("Example: publish --(repository|repo)=php --group=public --url=https://github.com/reporangler/lib-reporangler\n");
            print("  --(repository|repo)=php: The name of the repository that this package will be published into\n");
            print("  --group=public: The name of the package group that this package will be associated with\n");
            print("  --url=...: The url of the project from where to obtain packages from\n");
            print("\nNOTE: It's true that not all packages come from a VCS, but at the moment, it's the only supported type\n");
            die();
        }

        $fields = array_fill_keys(['repository','scan','package_group','url'], null);

        foreach($argList as $arg){
			list($arg, $value) = Command::extractArg($arg);

			switch($arg){
                case 'repository':
                case 'repo':
					$fields['repository'] = $value;
					break;

                case 'group':
					$fields['package_group'] = $value;
                    break;

                case 'url':
                    $fields['url'] = $value;
                    break;

                case 'scan':
                    $fields['scan'] = $value;
                    break;
            }
        }

        if($fields['scan'] === null){
			switch(true){
				case strpos($fields['url'], 'github') !== false:
					$fields['scan'] = 'github';
					break;

				case strpos($fields['url'], 'gitlab') !== false:
					$fields['scan'] = 'gitlab';
					break;

                default:
					$fields['scan'] = 'vcs';
                    break;
			}
        }

        if(in_array(null, $fields)){
            throw new CommandFieldEmptyException();
        }

		$endpoint = Config::getEndpoint($fields['repository']);
		$headers = Request::getTokenHeaders();

		$response = Request::post($endpoint, [
            'url' => $fields['url'],
            'type' => $fields['scan'],
            'package_group' => $fields['package_group'],
        ], $headers);

		foreach($response as $package => $version){
			print("Published Package: '$package' from '{$fields['url']}'\n");
			foreach(array_keys($version) as $version){
			    print("  - $version\n");
            }
        }
	}
}

class Config{
    const file = __DIR__ . '/.reporangler.config';
    const user_agent = 'reporangler-cli';

    const defaults = [
        'endpoints' => [
            'auth' => 'http://auth.reporangler.develop',
            'php' => 'http://php.reporangler.develop',
            'npm' => 'http://npm.reporangler.develop',
        ]
    ];

    static public $state = [];

    static public function read(){
        self::$state = file_exists(self::file)
            ? json_decode(file_get_contents(self::file), true)
            : self::defaults;
    }

    static public function write(){
        return file_put_contents(self::file, json_encode(self::$state, JSON_PRETTY_PRINT));
    }

    static public function getEndpoint($name)
    {
        if(empty(self::$state)) {
            die("State: Was empty");
        }

        if(!array_key_exists('endpoints', self::$state)) {
            die("State: Endpoints are not configured");
        }

        if(!array_key_exists($name, self::$state['endpoints'])) {
            die("State: Endpoint '$name' does not exist");
        }

        return self::$state['endpoints'][$name];
    }

    static public function setToken($token)
    {
        self::$state['login_token'] = $token;
    }

    static public function getToken()
    {
        return array_key_exists('login_token', self::$state)
            ? self::$state['login_token']
            : null;
    }

    static public function setUserId($userId)
    {
        self::$state['user_id'] = $userId;
    }

    static public function getUserId()
    {
        return self::$state['user_id'];
    }
}

class Request{
    static public $statusCode = 500;

    private function exec($method, $url, $data, $headers)
    {
        $curl = curl_init();

        $headers[] = 'Content-Type: application/json';

        // Coerce the method to a set of allowed types
        $method = in_array($method, ['GET', 'POST', 'PUT', 'DELETE']) ? $method : 'GET';

        curl_setopt($curl, CURLOPT_URL, $url);
        curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method);
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($curl, CURLOPT_USERAGENT, Config::user_agent);
        curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);

        if(!empty($data)){
            curl_setopt($curl, CURLOPT_POST, true);
            curl_setopt($curl, CURLOPT_POSTFIELDS, json_encode($data));
        }

        Request::$statusCode = 500;

        $result = curl_exec($curl);

        $statusCode = Request::$statusCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);

        if(!strlen($result)) throw new Exception('The api request returned an empty response');

        $json = json_decode($result, true);

        switch(Request::$statusCode){
            case 200:
                return $json;
                break;

            case 404:
                throw new RepoRanglerException("The resource was not found ($statusCode)", $json);
                break;

            case 422:
                switch($json['exception']){
                    case 'Illuminate\Validation\ValidationException':
                        throw new RepoRanglerValidationException($json);
                        break;

                    case 'Symfony\Component\HttpKernel\Exception\UnprocessableEntityHttpException':
                        throw new RepoRanglerAlreadyExistsException($json['message']);
                        break;
                }
        }

        throw new RepoRanglerException("There was a generic unknown error ($statusCode)", $json);
    }

    public function get($url, $headers=[])
    {
        return self::exec('GET', $url, null, $headers);
    }

    public function post($url, $data, $headers=[])
    {
        return self::exec('POST', $url, $data, $headers);
    }

    public function put($url, $data, $headers=[])
    {
        return self::exec('PUT', $url, $data, $headers);
    }

    public function delete($url, $headers=[])
    {
        return self::exec('DELETE', $url, null, $headers);
    }

    public function getLoginHeaders($username, $password)
    {
        return [
            "reporangler-login-type: database",
            "reporangler-login-username: $username",
            "reporangler-login-password: $password",
        ];
    }

    public function getTokenHeaders()
    {
        $token = Config::getToken();

        if(empty($token)){
            die("Token was empty, you must login first");
        }

        return ["Authorization: Bearer {$token}"];
    }
}

class Command
{
	static public function computeMethodName($arg)
	{
		$command = trim($arg,'-');
		$command = str_replace('-', ' ', $command);
		$command = ucwords($command);
		$command = str_replace(' ', '', $command);
		$command = lcfirst($command);

		if(method_exists("RepoRangler", $command)) return "RepoRangler::$command";

		$altArg = rtrim($arg, 's');
		if($altArg === $arg) return null;

		print("Command '$arg' did not exist, trying '$altArg'\n");
		return self::computeMethodName($altArg);
	}

	static public function extractArg($arg)
    {
		list($arg, $value) = explode("=",$arg) + [null, null];

		return [trim($arg,'-'), $value];
    }

    static public function hasHelp($argList)
    {
        if(!is_array($argList)) return false;

        foreach($argList as $arg){
            list($arg, $value) = self::extractArg($arg);

            if($arg === 'help') return true;
        }

        return false;
    }
}

class RepoRanglerException extends \Exception{
    public $data;

    public function __construct($message = null, $data = [])
    {
        $this->data = $data;

        parent::__construct($message);
    }
}
class RepoRanglerCurlException extends RepoRanglerException{}
class RepoRanglerAlreadyExistsException extends RepoRanglerException{}

class RepoRanglerValidationException extends RepoRanglerException{
    public function __construct($data = [])
    {
        $keys = implode(', ', array_keys($data['validation']));
        $message = "Validation has failed because the following fields were not valid: $keys";

        parent::__construct($message, $data['validation']);
    }
}

class CommandFieldEmptyException extends \Exception{}
